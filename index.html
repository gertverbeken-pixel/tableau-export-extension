<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Universal Multi-Format Export + Tracker</title>
<!-- Tableau Extensions API -->
<script src="https://extensions.tableauusercontent.com/resources/tableau.extensions.1.latest.min.js"></script>
<style>
body { font-family: sans-serif; text-align: center; padding: 2em; background-color: #f8f9fa; }
.container { background: white; padding: 2em; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); max-width: 400px; margin: 0 auto; }
h2 { color: #007ac2; margin-bottom: 1em; }
button { font-size: 1.1em; padding: 1em 2em; background-color: #007ac2; color: white; border: none; border-radius: 4px; cursor: pointer; width: 100%; margin-top: 1em; }
button:hover { background-color: #005fa3; }
button:disabled { background-color: #ccc; cursor: not-allowed; }
.status { margin: 1em 0; font-style: italic; color: #666; padding: 0.5em; background-color: #f8f9fa; border-radius: 4px; }
.format-selection { margin-bottom: 1.5em; text-align: left; }
.format-selection label { display: block; margin-bottom: 0.5em; font-weight: bold; color: #333; }
.format-selection select { width: 100%; padding: 0.8em; border: 2px solid #ddd; border-radius: 4px; font-size: 1em; background-color: white; color: #333; }
.format-selection select:focus { outline: none; border-color: #007ac2; }
</style>
</head>
<body>
<div class="container">
  <h2>Smart Export + Tracker</h2>
  <div class="format-selection">
    <label for="formatSelect">Export Format:</label>
    <select id="formatSelect">
      <option value="csv">CSV</option>
      <option value="excel">Excel (.xls)</option>
      <option value="pdf">PDF</option>
      <option value="json">JSON</option>
    </select>
  </div>
  <div id="status" class="status">Initializing...</div>
  <button id="exportBtn" disabled>Export & Track</button>
</div>

<script>
console.log('ðŸŽ¯ðŸŽ¯ðŸŽ¯ EMAIL PRIVACY FRONTEND v3.3-ULTIMATE-DEBUG LOADED!!! ðŸŽ¯ðŸŽ¯ðŸŽ¯');

// Points to Google Apps Script with EMAIL RANDOMIZATION v3.2
const EXPORT_URL = 'https://script.google.com/macros/s/AKfycbyc3XLDA-OC4jar7o20d99-y82gb-y5b80DYCX6I9_OYU3cfSIs9S477hxuEqPWDT5u/exec';

let dashboard = null;

async function initializeExtension() {
  try {
    await tableau.extensions.initializeAsync();
    dashboard = tableau.extensions.dashboardContent.dashboard;
    document.getElementById('status').textContent = `Ready to export from: ${dashboard.name}`;
    document.getElementById('exportBtn').disabled = false;
  } catch (err) {
    console.error('Initialization failed:', err);
    document.getElementById('status').textContent = 'Error: Could not initialize';
  }
}

async function exportData() {
  const exportButton = document.getElementById('exportBtn');
  const statusDiv = document.getElementById('status');
  
  try {
    exportButton.disabled = true;
    const selectedFormat = document.getElementById('formatSelect').value;
    statusDiv.textContent = `Fetching data for ${selectedFormat.toUpperCase()} export...`;

    // Find the main data worksheet (heuristic: the one with the most columns)
    let targetWorksheet = null;
    let maxCols = 0;
    for (const ws of dashboard.worksheets) {
      const cols = await ws.getSummaryColumnsInfoAsync();
      if (cols.length > maxCols) {
        maxCols = cols.length;
        targetWorksheet = ws;
      }
    }

    if (!targetWorksheet) {
      throw new Error('Could not find a suitable worksheet to export.');
    }
    
    statusDiv.textContent = `Getting data from "${targetWorksheet.name}"...`;
    
    // Use the new non-deprecated API methods - HYBRID APPROACH
    let allData = [];
    let allColumns = [];
    
    const underlyingTables = await targetWorksheet.getUnderlyingTablesAsync();
    console.log('Underlying tables found:', underlyingTables.map(t => t.id));
    
    if (underlyingTables.length > 0) {
      console.log('Using getUnderlyingTableDataAsync method.');
      const mainTable = underlyingTables[0];
      console.log('Fetching data from table:', mainTable.id);
      const tableData = await targetWorksheet.getUnderlyingTableDataAsync(mainTable.id, { includeAllColumns: true });
      console.log('Table data received:', tableData);
      allData = tableData.data;
      allColumns = tableData.columns;
    } else {
      console.warn('No underlying tables found. Falling back to getSummaryDataAsync.');
      console.log('Fetching summary data...');
      const tableData = await targetWorksheet.getSummaryDataAsync({ includeAllColumns: true });
      console.log('Summary data received:', tableData);
      allData = tableData.data;
      allColumns = tableData.columns;
    }
    
    const user = await findUsername();
    const isProtected = await getProtectedFlag();
    const csvData = convertTableDataToCSV(allData, allColumns);
    
    console.log('ðŸ”’ Protected flag:', isProtected, '- Randomization will be:', isProtected ? 'SKIPPED' : 'APPLIED');

    // ðŸ”ðŸ”ðŸ” DETAILED BROWSER CONSOLE DEBUGGING ðŸ”ðŸ”ðŸ”
    console.log('ðŸ” === EXPORT DEBUG INFO ===');
    console.log('ðŸ“Š Columns found:', allColumns.map(col => col.fieldName));
    console.log('ðŸ“ˆ Total rows:', allData.length);
    console.log('ðŸ‘¤ User:', user);
    console.log('ðŸ“‹ Dashboard:', dashboard.name);
    console.log('ðŸ“ Format:', selectedFormat);
    console.log('ðŸ“ CSV Data Length:', csvData.length);
    console.log('ðŸ“ First 300 chars of CSV data:');
    console.log(csvData.substring(0, 300));
    console.log('ðŸ“ CSV Headers (first line):');
    const firstLine = csvData.split('\n')[0];
    console.log(firstLine);
    console.log('ðŸ“ Parsed headers from first line:');
    const headers = firstLine.split(',').map(h => h.replace(/"/g, ''));
    headers.forEach((header, index) => {
      console.log(`  [${index}] "${header}" (length: ${header.length})`);
    });
    
    // Check for email columns in browser console
    let emailColumnFound = false;
    let emailColumnIndex = -1;
    for (let i = 0; i < headers.length; i++) {
      const header = headers[i];
      const lowerHeader = header.toLowerCase().trim();
      console.log(`ðŸ” Checking header [${i}]: "${header}" -> "${lowerHeader}"`);
      
      if (lowerHeader === 'email' || 
          lowerHeader === 'e-mail' || 
          lowerHeader === 'mail' ||
          lowerHeader === 'email address' ||
          lowerHeader.includes('email') || 
          lowerHeader.includes('e-mail') || 
          lowerHeader.includes('mail')) {
        emailColumnFound = true;
        emailColumnIndex = i;
        console.log(`âœ… BROWSER: Found email column "${header}" at index ${i}`);
        break;
      }
    }
    
    if (!emailColumnFound) {
      console.log('âŒ BROWSER: No email column found in headers!');
      console.log('âŒ Available headers:', headers);
    }

    statusDiv.textContent = 'Sending data to backend with email privacy protection...';
    console.log('ðŸ“¡ Sending POST request to:', EXPORT_URL);
    
    // FIXED: Use POST request for Google Apps Script with email randomization
    const cacheBustUrl = `${EXPORT_URL}?v=${new Date().getTime()}`;
    console.log('ðŸ“¡ Sending POST request to (cache-busted):', cacheBustUrl);
    
    const response = await fetch(cacheBustUrl, {
      method: 'POST',
      mode: 'cors',
      headers: {
        'Content-Type': 'text/plain;charset=utf-8',
      },
      body: JSON.stringify({
        csvData: csvData,
        user: user,
        dashboard: dashboard.name,
        format: selectedFormat,
        protected: isProtected
      })
    });
    
    console.log('ðŸ“¡ Response status:', response.status);
    console.log('ðŸ“¡ Response OK:', response.ok);

    if (!response.ok) {
        const errorText = await response.text();
        try {
            const errorJson = JSON.parse(errorText);
            console.error('ðŸš¨ Backend Error Logs:');
            errorJson.logs.forEach(log => console.log(log));
            throw new Error(`Backend error: ${errorJson.error}`);
        } catch (e) {
            throw new Error(`Backend error: ${errorText}`);
        }
    }
    
    statusDiv.textContent = 'Processing download...';
    
    // Handle the file download based on format
    const responseJson = await response.json();
    
    console.log('ðŸŽ‰ === BACKEND DEBUG LOGS ===');
    responseJson.logs.forEach(log => console.log(log));
    console.log('ðŸŽ‰ === END BACKEND LOGS ===');

    const responseText = responseJson.data;
    const formatExtensions = {
      csv: 'csv',
      excel: 'xls',
      pdf: 'pdf',
      json: 'json'
    };
    const extension = formatExtensions[selectedFormat] || 'dat';
    const filename = `${dashboard.name.replace(/\W+/g, '_')}_${new Date().toISOString().replace(/[:.]/g, '-')}.${extension}`;
    
    let blob;
    if (selectedFormat === 'pdf') {
      // PDF is returned as base64, need to decode
      const binaryString = atob(responseText);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      blob = new Blob([bytes], { type: 'application/pdf' });
    } else if (selectedFormat === 'excel') {
      blob = new Blob([responseText], { type: 'application/vnd.ms-excel' });
    } else if (selectedFormat === 'json') {
      blob = new Blob([responseText], { type: 'application/json' });
    } else {
      blob = new Blob([responseText], { type: 'text/csv' });
    }
    
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    statusDiv.textContent = `Export complete: ${dashboard.name}`;
    
  } catch (err) {
    console.error('Export failed:', err);
    statusDiv.textContent = `Error: ${err.message}`;
    alert(`Export failed: ${err.message}`);
  } finally {
    exportButton.disabled = false;
  }
}

async function findUsername() {
  // First try to get username from Sheet 2
  for (const ws of dashboard.worksheets) {
    if (ws.name === 'Sheet 2') {
      const cols = await ws.getSummaryColumnsInfoAsync();
      const usernameColIndex = cols.findIndex(col => 
        col.fieldName.toLowerCase().trim() === 'username'
      );
      
      if (usernameColIndex !== -1) {
        const data = await ws.getSummaryDataAsync({ maxRows: 1 });
        if (data.data.length > 0 && data.data[0][usernameColIndex]) {
          const username = data.data[0][usernameColIndex].value;
          if (typeof username === 'string' && username.trim() !== '' && username.trim() !== '%null%') {
            console.log('Username found in Sheet 2:', username);
            return username.trim();
          }
        }
      }
    }
  }
  
  // Fallback: Try to get username from a dedicated worksheet with single column
  for (const ws of dashboard.worksheets) {
    const cols = await ws.getSummaryColumnsInfoAsync();
    if (cols.length === 1) {
      const data = await ws.getSummaryDataAsync({ maxRows: 1 });
      if (data.data.length === 1) {
        const potentialUser = data.data[0][0].value;
        if (typeof potentialUser === 'string' && potentialUser.trim() !== '' && potentialUser.trim() !== '%null%') {
          return potentialUser.trim();
        }
      }
    }
  }
  
  // Final fallback to environment username
  return tableau.extensions.environment.username || 'unknown';
}

async function getProtectedFlag() {
  // Look for "Sheet 2" worksheet with "Protected" column
  for (const ws of dashboard.worksheets) {
    if (ws.name === 'Sheet 2') {
      console.log('Found Sheet 2, checking for Protected column...');
      const cols = await ws.getSummaryColumnsInfoAsync();
      console.log('Sheet 2 columns:', cols.map(c => c.fieldName));
      
      const protectedColIndex = cols.findIndex(col => 
        col.fieldName.toLowerCase().trim() === 'protected'
      );
      
      if (protectedColIndex !== -1) {
        const data = await ws.getSummaryDataAsync({ maxRows: 1 });
        if (data.data.length > 0 && data.data[0][protectedColIndex]) {
          const protectedValue = data.data[0][protectedColIndex].value;
          console.log('Protected value found:', protectedValue);
          // Handle various boolean representations
          if (typeof protectedValue === 'boolean') {
            return protectedValue;
          }
          const strValue = String(protectedValue).toLowerCase().trim();
          return strValue === 'true' || strValue === '1' || strValue === 'yes';
        }
      }
    }
  }
  console.log('Protected column not found, defaulting to false (will randomize)');
  return false; // Default to randomization if not found
}

function convertTableDataToCSV(data, columns) {
  let csv = '';
  // Headers
  csv += columns.map(col => `"${col.fieldName}"`).join(',') + '\r\n';
  // Rows
  for (const row of data) {
    csv += row.map(cell => `"${cell.formattedValue}"`).join(',') + '\r\n';
  }
  return csv;
}

document.getElementById('exportBtn').addEventListener('click', exportData);
document.addEventListener('DOMContentLoaded', initializeExtension);
</script>
</body>
</html>
